###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         19/Apr/2019  15:28:48
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash_ex.c
#    Command line =  
#        -f C:\Users\chris\AppData\Local\Temp\EW5324.tmp
#        ("L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash_ex.c"
#        -D USE_HAL_DRIVER -D STM32F429xx -lcN "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM\pwmtry\List"
#        -o "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM\pwmtry\Obj"
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Full.h" -I "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM/../Inc\"
#        -I "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\"
#        -I "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\"
#        -I "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\"
#        -I "L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM/../Drivers/CMSIS/Include\"
#        -Ohz -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM\pwmtry\List\stm32f4xx_hal_flash_ex.lst
#    Object file  =  
#        L:\Classes\MicroProcessor
#        Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\EWARM\pwmtry\Obj\stm32f4xx_hal_flash_ex.o
#
###############################################################################

L:\Classes\MicroProcessor Apps\Projects\ThatMemeyBoi\Microcontroller-FinalProject\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_flash_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the FLASH extension peripheral:
      8            *           + Extended programming operations functions
      9            *  
     10            @verbatim
     11            ==============================================================================
     12                             ##### Flash Extension features #####
     13            ==============================================================================
     14                     
     15            [..] Comparing to other previous devices, the FLASH interface for STM32F427xx/437xx and 
     16                 STM32F429xx/439xx devices contains the following additional features 
     17                 
     18                 (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write
     19                     capability (RWW)
     20                 (+) Dual bank memory organization       
     21                 (+) PCROP protection for all banks
     22             
     23                                ##### How to use this driver #####
     24            ==============================================================================
     25            [..] This driver provides functions to configure and program the FLASH memory 
     26                 of all STM32F427xx/437xx, STM32F429xx/439xx, STM32F469xx/479xx and STM32F446xx 
     27                 devices. It includes
     28                (#) FLASH Memory Erase functions: 
     29                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     30                          HAL_FLASH_Lock() functions
     31                     (++) Erase function: Erase sector, erase all sectors
     32                     (++) There are two modes of erase :
     33                       (+++) Polling Mode using HAL_FLASHEx_Erase()
     34                       (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()
     35                       
     36                (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to :
     37                     (++) Set/Reset the write protection
     38                     (++) Set the Read protection Level
     39                     (++) Set the BOR level
     40                     (++) Program the user Option Bytes
     41                (#) Advanced Option Bytes Programming functions: Use HAL_FLASHEx_AdvOBProgram() to :  
     42                 (++) Extended space (bank 2) erase function
     43                 (++) Full FLASH space (2 Mo) erase (bank 1 and bank 2)
     44                 (++) Dual Boot activation
     45                 (++) Write protection configuration for bank 2
     46                 (++) PCROP protection configuration and control for both banks
     47            
     48            @endverbatim
     49            ******************************************************************************
     50            * @attention
     51            *
     52            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     53            *
     54            * Redistribution and use in source and binary forms, with or without modification,
     55            * are permitted provided that the following conditions are met:
     56            *   1. Redistributions of source code must retain the above copyright notice,
     57            *      this list of conditions and the following disclaimer.
     58            *   2. Redistributions in binary form must reproduce the above copyright notice,
     59            *      this list of conditions and the following disclaimer in the documentation
     60            *      and/or other materials provided with the distribution.
     61            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     62            *      may be used to endorse or promote products derived from this software
     63            *      without specific prior written permission.
     64            *
     65            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     66            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     67            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     68            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     69            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     70            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     71            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     72            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     73            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     74            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     75            *
     76            ******************************************************************************
     77            */ 
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32f4xx_hal.h"
     81          
     82          /** @addtogroup STM32F4xx_HAL_Driver
     83            * @{
     84            */
     85          
     86          /** @defgroup FLASHEx FLASHEx
     87            * @brief FLASH HAL Extension module driver
     88            * @{
     89            */
     90          
     91          #ifdef HAL_FLASH_MODULE_ENABLED
     92          
     93          /* Private typedef -----------------------------------------------------------*/
     94          /* Private define ------------------------------------------------------------*/
     95          /** @addtogroup FLASHEx_Private_Constants
     96            * @{
     97            */    
     98          #define FLASH_TIMEOUT_VALUE       50000U /* 50 s */
     99          /**
    100            * @}
    101            */
    102              
    103          /* Private macro -------------------------------------------------------------*/
    104          /* Private variables ---------------------------------------------------------*/
    105          /** @addtogroup FLASHEx_Private_Variables
    106            * @{
    107            */    
    108          extern FLASH_ProcessTypeDef pFlash;
    109          /**
    110            * @}
    111            */
    112          
    113          /* Private function prototypes -----------------------------------------------*/
    114          /** @addtogroup FLASHEx_Private_Functions
    115            * @{
    116            */
    117          /* Option bytes control */
    118          static void               FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks);
    119          static HAL_StatusTypeDef  FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks);
    120          static HAL_StatusTypeDef  FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks);
    121          static HAL_StatusTypeDef  FLASH_OB_RDP_LevelConfig(uint8_t Level);
    122          static HAL_StatusTypeDef  FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby);
    123          static HAL_StatusTypeDef  FLASH_OB_BOR_LevelConfig(uint8_t Level);
    124          static uint8_t            FLASH_OB_GetUser(void);
    125          static uint16_t           FLASH_OB_GetWRP(void);
    126          static uint8_t            FLASH_OB_GetRDP(void);
    127          static uint8_t            FLASH_OB_GetBOR(void);
    128          
    129          #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) ||\
    130              defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
    131              defined(STM32F423xx)
    132          static HAL_StatusTypeDef  FLASH_OB_EnablePCROP(uint32_t Sector);
    133          static HAL_StatusTypeDef  FLASH_OB_DisablePCROP(uint32_t Sector);
    134          #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
    135                    STM32F413xx || STM32F423xx */
    136          
    137          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) 
    138          static HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks);
    139          static HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks);
    140          static HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t BootConfig);
    141          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    142          
    143          extern HAL_StatusTypeDef         FLASH_WaitForLastOperation(uint32_t Timeout);
    144          /**
    145            * @}
    146            */
    147          
    148          /* Exported functions --------------------------------------------------------*/
    149          /** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
    150            * @{
    151            */
    152          
    153          /** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions
    154           *  @brief   Extended IO operation functions 
    155           *
    156          @verbatim   
    157           ===============================================================================
    158                          ##### Extended programming operation functions #####
    159           ===============================================================================  
    160              [..]
    161              This subsection provides a set of functions allowing to manage the Extension FLASH 
    162              programming operations.
    163          
    164          @endverbatim
    165            * @{
    166            */
    167          /**
    168            * @brief  Perform a mass erase or erase the specified FLASH memory sectors 
    169            * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    170            *         contains the configuration information for the erasing.
    171            * 
    172            * @param[out]  SectorError pointer to variable  that
    173            *         contains the configuration information on faulty sector in case of error 
    174            *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
    175            * 
    176            * @retval HAL Status
    177            */
    178          HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
    179          {
    180            HAL_StatusTypeDef status = HAL_ERROR;
    181            uint32_t index = 0U;
    182            
    183            /* Process Locked */
    184            __HAL_LOCK(&pFlash);
    185          
    186            /* Check the parameters */
    187            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    188          
    189            /* Wait for last operation to be completed */
    190            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    191          
    192            if(status == HAL_OK)
    193            {
    194              /*Initialization of SectorError variable*/
    195              *SectorError = 0xFFFFFFFFU;
    196              
    197              if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
    198              {
    199                /*Mass erase to be done*/
    200                FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
    201          
    202                /* Wait for last operation to be completed */
    203                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    204                
    205                /* if the erase operation is completed, disable the MER Bit */
    206                FLASH->CR &= (~FLASH_MER_BIT);
    207              }
    208              else
    209              {
    210                /* Check the parameters */
    211                assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
    212          
    213                /* Erase by sector by sector to be done*/
    214                for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
    215                {
    216                  FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
    217          
    218                  /* Wait for last operation to be completed */
    219                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    220                  
    221                  /* If the erase operation is completed, disable the SER and SNB Bits */
    222                  CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
    223          
    224                  if(status != HAL_OK) 
    225                  {
    226                    /* In case of error, stop erase procedure and return the faulty sector*/
    227                    *SectorError = index;
    228                    break;
    229                  }
    230                }
    231              }
    232              /* Flush the caches to be sure of the data consistency */
    233              FLASH_FlushCaches();    
    234            }
    235          
    236            /* Process Unlocked */
    237            __HAL_UNLOCK(&pFlash);
    238          
    239            return status;
    240          }
    241          
    242          /**
    243            * @brief  Perform a mass erase or erase the specified FLASH memory sectors  with interrupt enabled
    244            * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    245            *         contains the configuration information for the erasing.
    246            * 
    247            * @retval HAL Status
    248            */
    249          HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
    250          {
    251            HAL_StatusTypeDef status = HAL_OK;
    252          
    253            /* Process Locked */
    254            __HAL_LOCK(&pFlash);
    255          
    256            /* Check the parameters */
    257            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    258          
    259            /* Enable End of FLASH Operation interrupt */
    260            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
    261            
    262            /* Enable Error source interrupt */
    263            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
    264            
    265            /* Clear pending flags (if any) */  
    266            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
    267                                   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_PGSERR);  
    268            
    269            if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
    270            {
    271              /*Mass erase to be done*/
    272              pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
    273              pFlash.Bank = pEraseInit->Banks;
    274              FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
    275            }
    276            else
    277            {
    278              /* Erase by sector to be done*/
    279          
    280              /* Check the parameters */
    281              assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
    282          
    283              pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;
    284              pFlash.NbSectorsToErase = pEraseInit->NbSectors;
    285              pFlash.Sector = pEraseInit->Sector;
    286              pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;
    287          
    288              /*Erase 1st sector and wait for IT*/
    289              FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);
    290            }
    291          
    292            return status;
    293          }
    294          
    295          /**
    296            * @brief   Program option bytes
    297            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    298            *         contains the configuration information for the programming.
    299            * 
    300            * @retval HAL Status
    301            */
    302          HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
    303          {
    304            HAL_StatusTypeDef status = HAL_ERROR;
    305            
    306            /* Process Locked */
    307            __HAL_LOCK(&pFlash);
    308          
    309            /* Check the parameters */
    310            assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
    311          
    312            /*Write protection configuration*/
    313            if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
    314            {
    315              assert_param(IS_WRPSTATE(pOBInit->WRPState));
    316              if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
    317              {
    318                /*Enable of Write protection on the selected Sector*/
    319                status = FLASH_OB_EnableWRP(pOBInit->WRPSector, pOBInit->Banks);
    320              }
    321              else
    322              {
    323                /*Disable of Write protection on the selected Sector*/
    324                status = FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
    325              }
    326            }
    327          
    328            /*Read protection configuration*/
    329            if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
    330            {
    331              status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
    332            }
    333          
    334            /*USER  configuration*/
    335            if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
    336            {
    337              status = FLASH_OB_UserConfig(pOBInit->USERConfig&OB_IWDG_SW, 
    338                                               pOBInit->USERConfig&OB_STOP_NO_RST,
    339                                               pOBInit->USERConfig&OB_STDBY_NO_RST);
    340            }
    341          
    342            /*BOR Level  configuration*/
    343            if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
    344            {
    345              status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
    346            }
    347          
    348            /* Process Unlocked */
    349            __HAL_UNLOCK(&pFlash);
    350          
    351            return status;
    352          }
    353          
    354          /**
    355            * @brief   Get the Option byte configuration
    356            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    357            *         contains the configuration information for the programming.
    358            * 
    359            * @retval None
    360            */
    361          void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
    362          {
    363            pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;
    364          
    365            /*Get WRP*/
    366            pOBInit->WRPSector = (uint32_t)FLASH_OB_GetWRP();
    367          
    368            /*Get RDP Level*/
    369            pOBInit->RDPLevel = (uint32_t)FLASH_OB_GetRDP();
    370          
    371            /*Get USER*/
    372            pOBInit->USERConfig = (uint8_t)FLASH_OB_GetUser();
    373          
    374            /*Get BOR Level*/
    375            pOBInit->BORLevel = (uint32_t)FLASH_OB_GetBOR();
    376          }
    377          
    378          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
    379              defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
    380              defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) ||\
    381              defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
    382              defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    383          /**
    384            * @brief   Program option bytes
    385            * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
    386            *         contains the configuration information for the programming.
    387            * 
    388            * @retval HAL Status
    389            */
    390          HAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
    391          {
    392            HAL_StatusTypeDef status = HAL_ERROR;
    393            
    394            /* Check the parameters */
    395            assert_param(IS_OBEX(pAdvOBInit->OptionType));
    396          
    397            /*Program PCROP option byte*/
    398            if(((pAdvOBInit->OptionType) & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)
    399            {
    400              /* Check the parameters */
    401              assert_param(IS_PCROPSTATE(pAdvOBInit->PCROPState));
    402              if((pAdvOBInit->PCROPState) == OB_PCROP_STATE_ENABLE)
    403              {
    404                /*Enable of Write protection on the selected Sector*/
    405          #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
    406              defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
    407              defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    408                status = FLASH_OB_EnablePCROP(pAdvOBInit->Sectors);
    409          #else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
    410                status = FLASH_OB_EnablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);
    411          #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
    412                    STM32F413xx || STM32F423xx */
    413              }
    414              else
    415              {
    416                /*Disable of Write protection on the selected Sector*/
    417          #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
    418              defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
    419              defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    420                status = FLASH_OB_DisablePCROP(pAdvOBInit->Sectors);
    421          #else /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
    422                status = FLASH_OB_DisablePCROP(pAdvOBInit->SectorsBank1, pAdvOBInit->SectorsBank2, pAdvOBInit->Banks);
    423          #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
    424                    STM32F413xx || STM32F423xx */
    425              }
    426            }
    427             
    428          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
    429            /*Program BOOT config option byte*/
    430            if(((pAdvOBInit->OptionType) & OPTIONBYTE_BOOTCONFIG) == OPTIONBYTE_BOOTCONFIG)
    431            {
    432              status = FLASH_OB_BootConfig(pAdvOBInit->BootConfig);
    433            }
    434          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    435          
    436            return status;
    437          }
    438          
    439          /**
    440            * @brief   Get the OBEX byte configuration
    441            * @param  pAdvOBInit pointer to an FLASH_AdvOBProgramInitTypeDef structure that
    442            *         contains the configuration information for the programming.
    443            * 
    444            * @retval None
    445            */
    446          void HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
    447          {
    448          #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
    449              defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
    450              defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    451            /*Get Sector*/
    452            pAdvOBInit->Sectors = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
    453          #else  /* STM32F427xx || STM32F437xx || STM32F429xx|| STM32F439xx || STM32F469xx || STM32F479xx */
    454            /*Get Sector for Bank1*/
    455            pAdvOBInit->SectorsBank1 = (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
    456          
    457            /*Get Sector for Bank2*/
    458            pAdvOBInit->SectorsBank2 = (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
    459          
    460            /*Get Boot config OB*/
    461            pAdvOBInit->BootConfig = *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS;
    462          #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
    463                    STM32F413xx || STM32F423xx */
    464          }
    465          
    466          /**
    467            * @brief  Select the Protection Mode 
    468            * 
    469            * @note   After PCROP activated Option Byte modification NOT POSSIBLE! excepted 
    470            *         Global Read Out Protection modification (from level1 to level0) 
    471            * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
    472            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    473            * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F401xx/STM32F411xx/STM32F446xx/
    474            *         STM32F469xx/STM32F479xx/STM32F412xx/STM32F413xx devices.
    475            * 
    476            * @retval HAL Status
    477            */
    478          HAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void)
    479          {
    480            uint8_t optiontmp = 0xFF;
    481          
    482            /* Mask SPRMOD bit */
    483            optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
    484            
    485            /* Update Option Byte */
    486            *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_SELECTED | optiontmp); 
    487            
    488            return HAL_OK;
    489          }
    490          
    491          /**
    492            * @brief  Deselect the Protection Mode 
    493            * 
    494            * @note   After PCROP activated Option Byte modification NOT POSSIBLE! excepted 
    495            *         Global Read Out Protection modification (from level1 to level0) 
    496            * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
    497            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    498            * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F401xx/STM32F411xx/STM32F446xx/
    499            *         STM32F469xx/STM32F479xx/STM32F412xx/STM32F413xx devices.
    500            * 
    501            * @retval HAL Status
    502            */
    503          HAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void)
    504          {
    505            uint8_t optiontmp = 0xFF;
    506            
    507            /* Mask SPRMOD bit */
    508            optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
    509            
    510            /* Update Option Byte */
    511            *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PCROP_DESELECTED | optiontmp);  
    512            
    513            return HAL_OK;
    514          }
    515          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F401xC || STM32F401xE || STM32F410xx ||\
    516                    STM32F411xE || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx ||
    517                    STM32F413xx || STM32F423xx */
    518          
    519          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
    520          /**
    521            * @brief  Returns the FLASH Write Protection Option Bytes value for Bank 2
    522            * @note   This function can be used only for STM32F42xxx/STM32F43xxx/STM32F469xx/STM32F479xx devices.  
    523            * @retval The FLASH Write Protection  Option Bytes value
    524            */
    525          uint16_t HAL_FLASHEx_OB_GetBank2WRP(void)
    526          {                            
    527            /* Return the FLASH write protection Register value */
    528            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
    529          }
    530          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    531          
    532          /**
    533            * @}
    534            */
    535            
    536          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
    537          /**
    538            * @brief  Full erase of FLASH memory sectors 
    539            * @param  VoltageRange The device voltage range which defines the erase parallelism.  
    540            *          This parameter can be one of the following values:
    541            *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
    542            *                                  the operation will be done by byte (8-bit) 
    543            *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
    544            *                                  the operation will be done by half word (16-bit)
    545            *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
    546            *                                  the operation will be done by word (32-bit)
    547            *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    548            *                                  the operation will be done by double word (64-bit)
    549            * 
    550            * @param  Banks Banks to be erased
    551            *          This parameter can be one of the following values:
    552            *            @arg FLASH_BANK_1: Bank1 to be erased
    553            *            @arg FLASH_BANK_2: Bank2 to be erased
    554            *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
    555            *
    556            * @retval HAL Status
    557            */
    558          static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
    559          {
    560            /* Check the parameters */
    561            assert_param(IS_VOLTAGERANGE(VoltageRange));
    562            assert_param(IS_FLASH_BANK(Banks));
    563          
    564            /* if the previous operation is completed, proceed to erase all sectors */
    565            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
    566          
    567            if(Banks == FLASH_BANK_BOTH)
    568            {
    569              /* bank1 & bank2 will be erased*/
    570              FLASH->CR |= FLASH_MER_BIT;
    571            }
    572            else if(Banks == FLASH_BANK_1)
    573            {
    574              /*Only bank1 will be erased*/
    575              FLASH->CR |= FLASH_CR_MER1;
    576            }
    577            else
    578            {
    579              /*Only bank2 will be erased*/
    580              FLASH->CR |= FLASH_CR_MER2;
    581            }
    582            FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
    583          }
    584          
    585          /**
    586            * @brief  Erase the specified FLASH memory sector
    587            * @param  Sector FLASH sector to erase
    588            *         The value of this parameter depend on device used within the same series      
    589            * @param  VoltageRange The device voltage range which defines the erase parallelism.  
    590            *          This parameter can be one of the following values:
    591            *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
    592            *                                  the operation will be done by byte (8-bit) 
    593            *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
    594            *                                  the operation will be done by half word (16-bit)
    595            *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
    596            *                                  the operation will be done by word (32-bit)
    597            *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    598            *                                  the operation will be done by double word (64-bit)
    599            * 
    600            * @retval None
    601            */
    602          void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
    603          {
    604            uint32_t tmp_psize = 0U;
    605          
    606            /* Check the parameters */
    607            assert_param(IS_FLASH_SECTOR(Sector));
    608            assert_param(IS_VOLTAGERANGE(VoltageRange));
    609            
    610            if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
    611            {
    612               tmp_psize = FLASH_PSIZE_BYTE;
    613            }
    614            else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
    615            {
    616              tmp_psize = FLASH_PSIZE_HALF_WORD;
    617            }
    618            else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
    619            {
    620              tmp_psize = FLASH_PSIZE_WORD;
    621            }
    622            else
    623            {
    624              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
    625            }
    626          
    627            /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */
    628            if(Sector > FLASH_SECTOR_11) 
    629            {
    630              Sector += 4U;
    631            }
    632            /* If the previous operation is completed, proceed to erase the sector */
    633            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
    634            FLASH->CR |= tmp_psize;
    635            CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
    636            FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
    637            FLASH->CR |= FLASH_CR_STRT;
    638          }
    639          
    640          /**
    641            * @brief  Enable the write protection of the desired bank1 or bank 2 sectors
    642            *
    643            * @note   When the memory read protection level is selected (RDP level = 1), 
    644            *         it is not possible to program or erase the flash sector i if CortexM4  
    645            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    646            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
    647            * 
    648            * @param  WRPSector specifies the sector(s) to be write protected.
    649            *          This parameter can be one of the following values:
    650            *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_23
    651            *            @arg OB_WRP_SECTOR_All
    652            * @note   BANK2 starts from OB_WRP_SECTOR_12
    653            *
    654            * @param  Banks Enable write protection on all the sectors for the specific bank
    655            *          This parameter can be one of the following values:
    656            *            @arg FLASH_BANK_1: WRP on all sectors of bank1
    657            *            @arg FLASH_BANK_2: WRP on all sectors of bank2
    658            *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 & bank2
    659            *
    660            * @retval HAL FLASH State   
    661            */
    662          static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
    663          {
    664            HAL_StatusTypeDef status = HAL_OK;
    665            
    666            /* Check the parameters */
    667            assert_param(IS_OB_WRP_SECTOR(WRPSector));
    668            assert_param(IS_FLASH_BANK(Banks));
    669              
    670            /* Wait for last operation to be completed */
    671            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    672          
    673            if(status == HAL_OK)
    674            {
    675              if(((WRPSector == OB_WRP_SECTOR_All) && ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))) ||
    676                   (WRPSector < OB_WRP_SECTOR_12))
    677              {
    678                 if(WRPSector == OB_WRP_SECTOR_All)
    679                 {
    680                    /*Write protection on all sector of BANK1*/
    681                    *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~(WRPSector>>12));  
    682                 }
    683                 else
    684                 {
    685                    /*Write protection done on sectors of BANK1*/
    686                    *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~WRPSector);  
    687                 }
    688              }
    689              else 
    690              {
    691                /*Write protection done on sectors of BANK2*/
    692                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~(WRPSector>>12));  
    693              }
    694          
    695              /*Write protection on all sector of BANK2*/
    696              if((WRPSector == OB_WRP_SECTOR_All) && (Banks == FLASH_BANK_BOTH))
    697              {
    698                /* Wait for last operation to be completed */
    699                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    700                
    701                if(status == HAL_OK)
    702                { 
    703                  *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~(WRPSector>>12));  
    704                }
    705              }
    706              
    707            }
    708            return status;
    709          }
    710          
    711          /**
    712            * @brief  Disable the write protection of the desired bank1 or bank 2 sectors
    713            *
    714            * @note   When the memory read protection level is selected (RDP level = 1), 
    715            *         it is not possible to program or erase the flash sector i if CortexM4  
    716            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    717            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
    718            * 
    719            * @param  WRPSector specifies the sector(s) to be write protected.
    720            *          This parameter can be one of the following values:
    721            *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_23
    722            *            @arg OB_WRP_Sector_All
    723            * @note   BANK2 starts from OB_WRP_SECTOR_12
    724            *
    725            * @param  Banks Disable write protection on all the sectors for the specific bank
    726            *          This parameter can be one of the following values:
    727            *            @arg FLASH_BANK_1: Bank1 to be erased
    728            *            @arg FLASH_BANK_2: Bank2 to be erased
    729            *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
    730            *
    731            * @retval HAL Status   
    732            */
    733          static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
    734          {
    735            HAL_StatusTypeDef status = HAL_OK;
    736            
    737            /* Check the parameters */
    738            assert_param(IS_OB_WRP_SECTOR(WRPSector));
    739            assert_param(IS_FLASH_BANK(Banks));
    740              
    741            /* Wait for last operation to be completed */
    742            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    743          
    744            if(status == HAL_OK)
    745            {
    746              if(((WRPSector == OB_WRP_SECTOR_All) && ((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))) ||
    747                   (WRPSector < OB_WRP_SECTOR_12))
    748              {
    749                 if(WRPSector == OB_WRP_SECTOR_All)
    750                 {
    751                    /*Write protection on all sector of BANK1*/
    752                    *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)(WRPSector>>12); 
    753                 }
    754                 else
    755                 {
    756                    /*Write protection done on sectors of BANK1*/
    757                    *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector; 
    758                 }
    759              }
    760              else 
    761              {
    762                /*Write protection done on sectors of BANK2*/
    763                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)(WRPSector>>12); 
    764              }
    765          
    766              /*Write protection on all sector  of BANK2*/
    767              if((WRPSector == OB_WRP_SECTOR_All) && (Banks == FLASH_BANK_BOTH))
    768              {
    769                /* Wait for last operation to be completed */
    770                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    771                
    772                if(status == HAL_OK)
    773                { 
    774                  *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)(WRPSector>>12); 
    775                }
    776              }
    777              
    778            }
    779          
    780            return status;
    781          }
    782          
    783          /**
    784            * @brief  Configure the Dual Bank Boot.
    785            *   
    786            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    787            *      
    788            * @param  BootConfig specifies the Dual Bank Boot Option byte.
    789            *          This parameter can be one of the following values:
    790            *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable
    791            *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled
    792            * @retval None
    793            */
    794          static HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t BootConfig)
    795          {
    796            HAL_StatusTypeDef status = HAL_OK;
    797          
    798            /* Check the parameters */
    799            assert_param(IS_OB_BOOT(BootConfig));
    800          
    801            /* Wait for last operation to be completed */  
    802            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    803          
    804            if(status == HAL_OK)
    805            { 
    806              /* Set Dual Bank Boot */
    807              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
    808              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= BootConfig;
    809            }
    810            
    811            return status;
    812          }
    813          
    814          /**
    815            * @brief  Enable the read/write protection (PCROP) of the desired 
    816            *         sectors of Bank 1 and/or Bank 2.
    817            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    818            * @param  SectorBank1 Specifies the sector(s) to be read/write protected or unprotected for bank1.
    819            *          This parameter can be one of the following values:
    820            *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_11
    821            *            @arg OB_PCROP_SECTOR__All                         
    822            * @param  SectorBank2 Specifies the sector(s) to be read/write protected or unprotected for bank2.
    823            *          This parameter can be one of the following values:
    824            *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_12 and OB_PCROP_SECTOR_23
    825            *            @arg OB_PCROP_SECTOR__All                         
    826            * @param  Banks Enable PCROP protection on all the sectors for the specific bank
    827            *          This parameter can be one of the following values:
    828            *            @arg FLASH_BANK_1: WRP on all sectors of bank1
    829            *            @arg FLASH_BANK_2: WRP on all sectors of bank2
    830            *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 & bank2
    831            *
    832            * @retval HAL Status  
    833            */
    834          static HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks)
    835          {
    836            HAL_StatusTypeDef status = HAL_OK;
    837            
    838            assert_param(IS_FLASH_BANK(Banks));
    839              
    840            /* Wait for last operation to be completed */
    841            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    842          
    843            if(status == HAL_OK)
    844            {
    845              if((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))
    846              {
    847                assert_param(IS_OB_PCROP(SectorBank1));
    848                /*Write protection done on sectors of BANK1*/
    849                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)SectorBank1; 
    850              }
    851              else 
    852              {
    853                assert_param(IS_OB_PCROP(SectorBank2));
    854                /*Write protection done on sectors of BANK2*/
    855                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)SectorBank2; 
    856              }
    857          
    858              /*Write protection on all sector  of BANK2*/
    859              if(Banks == FLASH_BANK_BOTH)
    860              {
    861                assert_param(IS_OB_PCROP(SectorBank2));
    862                /* Wait for last operation to be completed */
    863                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    864                
    865                if(status == HAL_OK)
    866                { 
    867                  /*Write protection done on sectors of BANK2*/
    868                  *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)SectorBank2; 
    869                }
    870              }
    871              
    872            }
    873          
    874            return status;
    875          }
    876          
    877          
    878          /**
    879            * @brief  Disable the read/write protection (PCROP) of the desired 
    880            *         sectors  of Bank 1 and/or Bank 2.
    881            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    882            * @param  SectorBank1 specifies the sector(s) to be read/write protected or unprotected for bank1.
    883            *          This parameter can be one of the following values:
    884            *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_11
    885            *            @arg OB_PCROP_SECTOR__All                         
    886            * @param  SectorBank2 Specifies the sector(s) to be read/write protected or unprotected for bank2.
    887            *          This parameter can be one of the following values:
    888            *            @arg OB_PCROP: A value between OB_PCROP_SECTOR_12 and OB_PCROP_SECTOR_23
    889            *            @arg OB_PCROP_SECTOR__All                         
    890            * @param  Banks Disable PCROP protection on all the sectors for the specific bank
    891            *          This parameter can be one of the following values:
    892            *            @arg FLASH_BANK_1: WRP on all sectors of bank1
    893            *            @arg FLASH_BANK_2: WRP on all sectors of bank2
    894            *            @arg FLASH_BANK_BOTH: WRP on all sectors of bank1 & bank2
    895            *
    896            * @retval HAL Status  
    897            */
    898          static HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t SectorBank1, uint32_t SectorBank2, uint32_t Banks)
    899          {  
    900            HAL_StatusTypeDef status = HAL_OK;
    901            
    902            /* Check the parameters */
    903            assert_param(IS_FLASH_BANK(Banks));
    904              
    905            /* Wait for last operation to be completed */
    906            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    907          
    908            if(status == HAL_OK)
    909            {
    910              if((Banks == FLASH_BANK_1) || (Banks == FLASH_BANK_BOTH))
    911              {
    912                assert_param(IS_OB_PCROP(SectorBank1));
    913                /*Write protection done on sectors of BANK1*/
    914                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~SectorBank1); 
    915              }
    916              else 
    917              {
    918                /*Write protection done on sectors of BANK2*/
    919                assert_param(IS_OB_PCROP(SectorBank2));
    920                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~SectorBank2); 
    921              }
    922          
    923              /*Write protection on all sector  of BANK2*/
    924              if(Banks == FLASH_BANK_BOTH)
    925              {
    926                assert_param(IS_OB_PCROP(SectorBank2));
    927               /* Wait for last operation to be completed */
    928                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    929                
    930                if(status == HAL_OK)
    931                { 
    932                  /*Write protection done on sectors of BANK2*/
    933                  *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~SectorBank2); 
    934                }
    935              }
    936              
    937            }
    938            
    939            return status;
    940          
    941          }
    942          
    943          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    944          
    945          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) ||\
    946              defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) ||\
    947              defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) ||\
    948              defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||\
    949              defined(STM32F423xx)
    950          /**
    951            * @brief  Mass erase of FLASH memory
    952            * @param  VoltageRange The device voltage range which defines the erase parallelism.  
    953            *          This parameter can be one of the following values:
    954            *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
    955            *                                  the operation will be done by byte (8-bit) 
    956            *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
    957            *                                  the operation will be done by half word (16-bit)
    958            *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
    959            *                                  the operation will be done by word (32-bit)
    960            *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    961            *                                  the operation will be done by double word (64-bit)
    962            * 
    963            * @param  Banks Banks to be erased
    964            *          This parameter can be one of the following values:
    965            *            @arg FLASH_BANK_1: Bank1 to be erased
    966            *
    967            * @retval None
    968            */
    969          static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
    970          {
    971            /* Check the parameters */
    972            assert_param(IS_VOLTAGERANGE(VoltageRange));
    973            assert_param(IS_FLASH_BANK(Banks));
    974            
    975            /* If the previous operation is completed, proceed to erase all sectors */
    976            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
    977            FLASH->CR |= FLASH_CR_MER;
    978            FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
    979          }
    980          
    981          /**
    982            * @brief  Erase the specified FLASH memory sector
    983            * @param  Sector FLASH sector to erase
    984            *         The value of this parameter depend on device used within the same series      
    985            * @param  VoltageRange The device voltage range which defines the erase parallelism.  
    986            *          This parameter can be one of the following values:
    987            *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
    988            *                                  the operation will be done by byte (8-bit) 
    989            *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
    990            *                                  the operation will be done by half word (16-bit)
    991            *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
    992            *                                  the operation will be done by word (32-bit)
    993            *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    994            *                                  the operation will be done by double word (64-bit)
    995            * 
    996            * @retval None
    997            */
    998          void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
    999          {
   1000            uint32_t tmp_psize = 0U;
   1001          
   1002            /* Check the parameters */
   1003            assert_param(IS_FLASH_SECTOR(Sector));
   1004            assert_param(IS_VOLTAGERANGE(VoltageRange));
   1005            
   1006            if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
   1007            {
   1008               tmp_psize = FLASH_PSIZE_BYTE;
   1009            }
   1010            else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
   1011            {
   1012              tmp_psize = FLASH_PSIZE_HALF_WORD;
   1013            }
   1014            else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
   1015            {
   1016              tmp_psize = FLASH_PSIZE_WORD;
   1017            }
   1018            else
   1019            {
   1020              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   1021            }
   1022          
   1023            /* If the previous operation is completed, proceed to erase the sector */
   1024            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   1025            FLASH->CR |= tmp_psize;
   1026            CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
   1027            FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
   1028            FLASH->CR |= FLASH_CR_STRT;
   1029          }
   1030          
   1031          /**
   1032            * @brief  Enable the write protection of the desired bank 1 sectors
   1033            *
   1034            * @note   When the memory read protection level is selected (RDP level = 1), 
   1035            *         it is not possible to program or erase the flash sector i if CortexM4  
   1036            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
   1037            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
   1038            * 
   1039            * @param  WRPSector specifies the sector(s) to be write protected.
   1040            *         The value of this parameter depend on device used within the same series 
   1041            * 
   1042            * @param  Banks Enable write protection on all the sectors for the specific bank
   1043            *          This parameter can be one of the following values:
   1044            *            @arg FLASH_BANK_1: WRP on all sectors of bank1
   1045            *
   1046            * @retval HAL Status 
   1047            */
   1048          static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
   1049          {
   1050            HAL_StatusTypeDef status = HAL_OK;
   1051            
   1052            /* Check the parameters */
   1053            assert_param(IS_OB_WRP_SECTOR(WRPSector));
   1054            assert_param(IS_FLASH_BANK(Banks));
   1055              
   1056            /* Wait for last operation to be completed */
   1057            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   1058          
   1059            if(status == HAL_OK)
   1060            { 
   1061              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~WRPSector);  
   1062            }
   1063            
   1064            return status;
   1065          }
   1066          
   1067          /**
   1068            * @brief  Disable the write protection of the desired bank 1 sectors
   1069            *
   1070            * @note   When the memory read protection level is selected (RDP level = 1), 
   1071            *         it is not possible to program or erase the flash sector i if CortexM4  
   1072            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
   1073            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
   1074            * 
   1075            * @param  WRPSector specifies the sector(s) to be write protected.
   1076            *         The value of this parameter depend on device used within the same series 
   1077            * 
   1078            * @param  Banks Enable write protection on all the sectors for the specific bank
   1079            *          This parameter can be one of the following values:
   1080            *            @arg FLASH_BANK_1: WRP on all sectors of bank1
   1081            *
   1082            * @retval HAL Status 
   1083            */
   1084          static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
   1085          {
   1086            HAL_StatusTypeDef status = HAL_OK;
   1087            
   1088            /* Check the parameters */
   1089            assert_param(IS_OB_WRP_SECTOR(WRPSector));
   1090            assert_param(IS_FLASH_BANK(Banks));
   1091              
   1092            /* Wait for last operation to be completed */
   1093            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   1094          
   1095            if(status == HAL_OK)
   1096            { 
   1097              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector; 
   1098            }
   1099            
   1100            return status;
   1101          }
   1102          #endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
   1103                    STM32F413xx || STM32F423xx */
   1104          
   1105          #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
   1106              defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) ||\
   1107              defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
   1108          /**
   1109            * @brief  Enable the read/write protection (PCROP) of the desired sectors.
   1110            * @note   This function can be used only for STM32F401xx devices.
   1111            * @param  Sector specifies the sector(s) to be read/write protected or unprotected.
   1112            *          This parameter can be one of the following values:
   1113            *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector5
   1114            *            @arg OB_PCROP_Sector_All                         
   1115            * @retval HAL Status  
   1116            */
   1117          static HAL_StatusTypeDef FLASH_OB_EnablePCROP(uint32_t Sector)
   1118          {
   1119            HAL_StatusTypeDef status = HAL_OK;
   1120            
   1121            /* Check the parameters */
   1122            assert_param(IS_OB_PCROP(Sector));
   1123              
   1124            /* Wait for last operation to be completed */  
   1125            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   1126          
   1127            if(status == HAL_OK)
   1128            { 
   1129              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)Sector;
   1130            }
   1131            
   1132            return status;
   1133          }
   1134          
   1135          
   1136          /**
   1137            * @brief  Disable the read/write protection (PCROP) of the desired sectors.
   1138            * @note   This function can be used only for STM32F401xx devices.
   1139            * @param  Sector specifies the sector(s) to be read/write protected or unprotected.
   1140            *          This parameter can be one of the following values:
   1141            *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector5
   1142            *            @arg OB_PCROP_Sector_All                         
   1143            * @retval HAL Status  
   1144            */
   1145          static HAL_StatusTypeDef FLASH_OB_DisablePCROP(uint32_t Sector)
   1146          {  
   1147            HAL_StatusTypeDef status = HAL_OK;
   1148            
   1149            /* Check the parameters */
   1150            assert_param(IS_OB_PCROP(Sector));
   1151              
   1152            /* Wait for last operation to be completed */  
   1153            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   1154          
   1155            if(status == HAL_OK)
   1156            { 
   1157              *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~Sector);
   1158            }
   1159            
   1160            return status;
   1161          
   1162          }
   1163          #endif /* STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F412Zx || STM32F412Vx || STM32F412Rx || STM32F412Cx
   1164                    STM32F413xx || STM32F423xx */
   1165          
   1166          /**
   1167            * @brief  Set the read protection level.
   1168            * @param  Level specifies the read protection level.
   1169            *          This parameter can be one of the following values:
   1170            *            @arg OB_RDP_LEVEL_0: No protection
   1171            *            @arg OB_RDP_LEVEL_1: Read protection of the memory
   1172            *            @arg OB_RDP_LEVEL_2: Full chip protection
   1173            *   
   1174            * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
   1175            *    
   1176            * @retval HAL Status
   1177            */
   1178          static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)
   1179          {
   1180            HAL_StatusTypeDef status = HAL_OK;
   1181            
   1182            /* Check the parameters */
   1183            assert_param(IS_OB_RDP_LEVEL(Level));
   1184              
   1185            /* Wait for last operation to be completed */
   1186            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   1187          
   1188            if(status == HAL_OK)
   1189            { 
   1190              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = Level;
   1191            }
   1192            
   1193            return status;
   1194          }
   1195          
   1196          /**
   1197            * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
   1198            * @param  Iwdg Selects the IWDG mode
   1199            *          This parameter can be one of the following values:
   1200            *            @arg OB_IWDG_SW: Software IWDG selected
   1201            *            @arg OB_IWDG_HW: Hardware IWDG selected
   1202            * @param  Stop Reset event when entering STOP mode.
   1203            *          This parameter  can be one of the following values:
   1204            *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP
   1205            *            @arg OB_STOP_RST: Reset generated when entering in STOP
   1206            * @param  Stdby Reset event when entering Standby mode.
   1207            *          This parameter  can be one of the following values:
   1208            *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY
   1209            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1210            * @retval HAL Status
   1211            */
   1212          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby)
   1213          {
   1214            uint8_t optiontmp = 0xFF;
   1215            HAL_StatusTypeDef status = HAL_OK;
   1216          
   1217            /* Check the parameters */
   1218            assert_param(IS_OB_IWDG_SOURCE(Iwdg));
   1219            assert_param(IS_OB_STOP_SOURCE(Stop));
   1220            assert_param(IS_OB_STDBY_SOURCE(Stdby));
   1221          
   1222            /* Wait for last operation to be completed */
   1223            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   1224            
   1225            if(status == HAL_OK)
   1226            {     
   1227              /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
   1228              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
   1229          
   1230              /* Update User Option Byte */
   1231              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = Iwdg | (uint8_t)(Stdby | (uint8_t)(Stop | ((uint8_t)optiontmp))); 
   1232            }
   1233            
   1234            return status; 
   1235          }
   1236          
   1237          /**
   1238            * @brief  Set the BOR Level. 
   1239            * @param  Level specifies the Option Bytes BOR Reset Level.
   1240            *          This parameter can be one of the following values:
   1241            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1242            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1243            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1244            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
   1245            * @retval HAL Status
   1246            */
   1247          static HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)
   1248          {
   1249            /* Check the parameters */
   1250            assert_param(IS_OB_BOR_LEVEL(Level));
   1251          
   1252            /* Set the BOR Level */
   1253            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   1254            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= Level;
   1255            
   1256            return HAL_OK;
   1257            
   1258          }
   1259          
   1260          /**
   1261            * @brief  Return the FLASH User Option Byte value.
   1262            * @retval uint8_t FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
   1263            *         and RST_STDBY(Bit2).
   1264            */
   1265          static uint8_t FLASH_OB_GetUser(void)
   1266          {
   1267            /* Return the User Option Byte */
   1268            return ((uint8_t)(FLASH->OPTCR & 0xE0));
   1269          }
   1270          
   1271          /**
   1272            * @brief  Return the FLASH Write Protection Option Bytes value.
   1273            * @retval uint16_t FLASH Write Protection Option Bytes value
   1274            */
   1275          static uint16_t FLASH_OB_GetWRP(void)
   1276          {
   1277            /* Return the FLASH write protection Register value */
   1278            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   1279          }
   1280          
   1281          /**
   1282            * @brief  Returns the FLASH Read Protection level.
   1283            * @retval FLASH ReadOut Protection Status:
   1284            *         This parameter can be one of the following values:
   1285            *            @arg OB_RDP_LEVEL_0: No protection
   1286            *            @arg OB_RDP_LEVEL_1: Read protection of the memory
   1287            *            @arg OB_RDP_LEVEL_2: Full chip protection
   1288            */
   1289          static uint8_t FLASH_OB_GetRDP(void)
   1290          {
   1291            uint8_t readstatus = OB_RDP_LEVEL_0;
   1292          
   1293            if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_2))
   1294            {
   1295              readstatus = OB_RDP_LEVEL_2;
   1296            }
   1297            else if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) == (uint8_t)OB_RDP_LEVEL_1))
   1298            {
   1299              readstatus = OB_RDP_LEVEL_1;
   1300            }
   1301            else 
   1302            {
   1303              readstatus = OB_RDP_LEVEL_0;
   1304            }
   1305          
   1306            return readstatus;
   1307          }
   1308          
   1309          /**
   1310            * @brief  Returns the FLASH BOR level.
   1311            * @retval uint8_t The FLASH BOR level:
   1312            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1313            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1314            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1315            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
   1316            */
   1317          static uint8_t FLASH_OB_GetBOR(void)
   1318          {
   1319            /* Return the FLASH BOR level */
   1320            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
   1321          }
   1322          
   1323          /**
   1324            * @brief  Flush the instruction and data caches
   1325            * @retval None
   1326            */
   1327          void FLASH_FlushCaches(void)
   1328          {
   1329            /* Flush instruction cache  */
   1330            if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
   1331            {
   1332              /* Disable instruction cache  */
   1333              __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
   1334              /* Reset instruction cache */
   1335              __HAL_FLASH_INSTRUCTION_CACHE_RESET();
   1336              /* Enable instruction cache */
   1337              __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   1338            }
   1339            
   1340            /* Flush data cache */
   1341            if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
   1342            {
   1343              /* Disable data cache  */
   1344              __HAL_FLASH_DATA_CACHE_DISABLE();
   1345              /* Reset data cache */
   1346              __HAL_FLASH_DATA_CACHE_RESET();
   1347              /* Enable data cache */
   1348              __HAL_FLASH_DATA_CACHE_ENABLE();
   1349            }
   1350          }
   1351          
   1352          /**
   1353            * @}
   1354            */
   1355            
   1356          #endif /* HAL_FLASH_MODULE_ENABLED */
   1357          
   1358          /**
   1359            * @}
   1360            */
   1361          
   1362          /**
   1363            * @}
   1364            */
   1365          
   1366          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FLASH_Erase_Sector
       0   FLASH_FlushCaches
       0   FLASH_MassErase
       0   HAL_FLASHEx_AdvOBGetConfig
      32   HAL_FLASHEx_AdvOBProgram
        32   -> FLASH_WaitForLastOperation
      32   HAL_FLASHEx_Erase
        32   -> FLASH_Erase_Sector
        32   -> FLASH_FlushCaches
        32   -> FLASH_MassErase
        32   -> FLASH_WaitForLastOperation
       8   HAL_FLASHEx_Erase_IT
         8   -> FLASH_Erase_Sector
         8   -> FLASH_MassErase
       0   HAL_FLASHEx_OBGetConfig
      40   HAL_FLASHEx_OBProgram
        40   -> FLASH_WaitForLastOperation
       0   HAL_FLASHEx_OB_DeSelectPCROP
       0   HAL_FLASHEx_OB_GetBank2WRP
       0   HAL_FLASHEx_OB_SelectPCROP


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      82  FLASH_Erase_Sector
      80  FLASH_FlushCaches
      58  FLASH_MassErase
      16  HAL_FLASHEx_AdvOBGetConfig
     156  HAL_FLASHEx_AdvOBProgram
     150  HAL_FLASHEx_Erase
     100  HAL_FLASHEx_Erase_IT
      50  HAL_FLASHEx_OBGetConfig
     312  HAL_FLASHEx_OBProgram
       8  HAL_FLASHEx_OB_DeSelectPCROP
       6  HAL_FLASHEx_OB_GetBank2WRP
      10  HAL_FLASHEx_OB_SelectPCROP

 
 1 082 bytes in section .text
 
 1 082 bytes of CODE memory

Errors: none
Warnings: none
